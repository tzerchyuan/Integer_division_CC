{\rtf1\ansi\ansicpg1252\cocoartf1404\cocoasubrtf340
{\fonttbl\f0\fmodern\fcharset0 Courier;\f1\fnil\fcharset0 HelveticaNeue;}
{\colortbl;\red255\green255\blue255;\red25\green25\blue25;\red255\green255\blue255;}
\margl1440\margr1440\vieww10800\viewh8400\viewkind0
\deftab720
\pard\pardeftab720\sl390\partightenfactor0

\f0\fs26 \cf2 \cb3 \expnd0\expndtw0\kerning0
\outl0\strokewidth0 \strokec2 ## The problem
\f1 \
\pard\pardeftab720\sl390\partightenfactor0

\f0 \cf2 \cb1 \
\pard\pardeftab720\sl390\partightenfactor0
\cf2 \cb3 Your task is to implement integer division without using the division operator. That is, given a numerator (dividend) and denominator (divisor), return the quotient and remainder, or return an error when the denominator is zero. Either or both of the inputs may be negative. The remainder should have the same sign as the denominator. Of course, the absolute value of the remainder should be less than that of the denominator. For example:
\f1 \
\pard\pardeftab720\sl390\partightenfactor0

\f0 \cf2 \cb1 \
\pard\pardeftab720\sl390\partightenfactor0
\cf2 \cb3 \'a0 \'a0 \'a06 / \'a05 == \'a01 r \'a01
\f1 \

\f0 \'a0 \'a0 \'a06 / -5 == -2 r -4
\f1 \

\f0 \'a0 \'a0 -6 / \'a05 == -2 r \'a04
\f1 \

\f0 \'a0 \'a0 -6 / -5 == \'a01 r -1
\f1 \
\pard\pardeftab720\sl390\partightenfactor0

\f0 \cf2 \cb1 \
\pard\pardeftab720\sl390\partightenfactor0
\cf2 \cb3 ## The approach we'd like to see in the solution
\f1 \
\pard\pardeftab720\sl390\partightenfactor0

\f0 \cf2 \cb1 \
\pard\pardeftab720\sl390\partightenfactor0
\cf2 \cb3 Essentially, we'd like you to use binary search to find the quotient:
\f1 \
\pard\pardeftab720\sl390\partightenfactor0

\f0 \cf2 \cb1 \
\pard\pardeftab720\sl390\partightenfactor0
\cf2 \cb3 \'a0- use the numerator and denominator to bracket the possible range for the quotient
\f1 \

\f0 \'a0- iterate (using binary search) within that range to determine the quotient that, when multiplied by the given denominator, brings you closest to the numerator (either over or under depending on the sign of the denominator)
\f1 \

\f0 \'a0- finally, compute the remainder and return the results of the computation in a way that's idiomatic to your language of choice
\f1 \
\pard\pardeftab720\sl390\partightenfactor0

\f0 \cf2 \cb1 \
\pard\pardeftab720\sl390\partightenfactor0
\cf2 \cb3 Your solution should be written in one of the following languages (presented in alphabetical order \'96 all are equally acceptable!): C++, Go, Java, JavaScript, Objective C, Python, or Ruby. It should be possible to run automated tests as well as manually invoke your code for user-supplied <numerator, denominator> pairs. Note that the tests *are* permitted to use the language's built-in division operator.
\f1 \
\pard\pardeftab720\sl390\partightenfactor0

\f0 \cf2 \cb1 \
\pard\pardeftab720\sl390\partightenfactor0
\cf2 \cb3 ## Evaluation
\f1 \
\pard\pardeftab720\sl390\partightenfactor0

\f0 \cf2 \cb1 \
\pard\pardeftab720\sl390\partightenfactor0
\cf2 \cb3 Your solution will be evaluated for its correctness, but also as a piece of software that we can read easily and maintain happily. We care about:
\f1 \
\pard\pardeftab720\sl390\partightenfactor0

\f0 \cf2 \cb1 \
\pard\pardeftab720\sl390\partightenfactor0
\cf2 \cb3 \'a0- style (which should be internally consistent at least, and ideally idiomatic given your language of choice)
\f1 \

\f0 \'a0- commenting and readability
\f1 \

\f0 \'a0- test coverage and design
\f1 \
\pard\pardeftab720\sl390\partightenfactor0

\f0 \cf2 \cb1 \
\pard\pardeftab720\sl390\partightenfactor0
\cf2 \cb3 As with real code, longer solutions are not necessarily better.
\f1 \
\pard\pardeftab720\sl390\partightenfactor0

\f0 \cf2 \cb1 \
\pard\pardeftab720\sl390\partightenfactor0
\cf2 \cb3 If you have any questions about our expectations, just ask!
\f1 \
}